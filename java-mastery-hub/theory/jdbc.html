<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java JDBC in Depth - Java Mastery Hub</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <!-- Header -->
    <header>
        <div class="header-content">
            <div class="logo">
                <span class="logo-icon">‚òï</span>
                <span>Java Mastery Hub</span>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Content Header -->
        <div class="content-header">
            <h1>Java JDBC in Depth</h1>
            <div class="breadcrumb">
                <a href="../index.html">Home</a>
                <span>/</span>
                <span>Theory</span>
                <span>/</span>
                <span>JDBC</span>
            </div>
        </div>

        <!-- Section 1: What is JDBC? -->
        <div class="content-section">
            <h2>üîå What is JDBC?</h2>

            <h3>Level 1: Beginner-Friendly Explanation (Like Explaining to a Baby)</h3>
            <p>
                Imagine you want to talk to your friend who lives far away. You use a <strong>phone</strong> to connect
                and talk! JDBC is like that phone‚Äîit helps your Java program <strong>talk to a database</strong> (where
                all the important information is stored).
            </p>
            <p>
                Without JDBC, your Java program can't ask the database for information or save new data. It's like
                trying to talk to someone without a phone!
            </p>

            <h3>Level 2: Real-World Analogy</h3>
            <p>
                Think of a <strong>mobile banking app</strong>:
            </p>
            <ul>
                <li><strong>Your Phone (Java App):</strong> The app you see and interact with.</li>
                <li><strong>The Bank's Vault (Database):</strong> Where all your money and transaction records are
                    stored.</li>
                <li><strong>The Connection (JDBC):</strong> The secure line that lets your app check your balance,
                    transfer money, etc.</li>
            </ul>
            <p>
                JDBC is the bridge that connects your Java application to any database (MySQL, PostgreSQL, Oracle,
                etc.).
            </p>

            <h3>Level 3: Technical Deep-Dive</h3>
            <p>
                <strong>JDBC (Java Database Connectivity)</strong> is a Java API that defines how a client may access a
                database. It provides methods for querying and updating data in a database and is oriented toward
                relational databases.
            </p>
            <p>
                JDBC is part of the Java Standard Edition platform from Oracle Corporation. It consists of a set of
                classes and interfaces written in Java that provide a standard API for database access.
            </p>

            <div class="callout note">
                <div class="callout-title">üìö NOTE</div>
                <p>JDBC is database-independent. You can connect to MySQL, PostgreSQL, Oracle, SQL Server, or any
                    database that has a JDBC driver.</p>
            </div>
        </div>

        <!-- Section 2: JDBC Architecture -->
        <div class="content-section">
            <h2>üèóÔ∏è JDBC Architecture</h2>

            <h3>Components of JDBC</h3>
            <p>JDBC architecture consists of two layers:</p>
            <ol>
                <li><strong>JDBC API:</strong> Application-to-JDBC Manager connection</li>
                <li><strong>JDBC Driver API:</strong> JDBC Manager-to-Driver connection</li>
            </ol>

            <h3>Key Components</h3>
            <ul>
                <li><strong>DriverManager:</strong> Manages a list of database drivers. Matches connection requests
                    from the Java application with the proper database driver.</li>
                <li><strong>Connection:</strong> Represents a connection with a specific database. All SQL statements
                    are executed within the context of a Connection.</li>
                <li><strong>Statement:</strong> Used to execute SQL queries against the database.</li>
                <li><strong>PreparedStatement:</strong> Pre-compiled SQL statement (safer and faster).</li>
                <li><strong>CallableStatement:</strong> Used to execute stored procedures.</li>
                <li><strong>ResultSet:</strong> Represents the result set of a database query.</li>
            </ul>

            <h3>JDBC Flow Diagram</h3>
            <pre
                style="background: var(--bg-hover); padding: var(--spacing-md); border-radius: var(--radius-sm); border-left: 4px solid var(--primary);">
Java Application
    ‚Üì
DriverManager (loads driver)
    ‚Üì
Connection (establishes connection)
    ‚Üì
Statement/PreparedStatement (creates SQL query)
    ‚Üì
Execute Query
    ‚Üì
ResultSet (retrieve results)
    ‚Üì
Close Resources
            </pre>

            <h3>JDBC Driver Types</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Name</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Type 1</strong></td>
                        <td>JDBC-ODBC Bridge</td>
                        <td>Uses ODBC driver to connect (deprecated)</td>
                    </tr>
                    <tr>
                        <td><strong>Type 2</strong></td>
                        <td>Native-API Driver</td>
                        <td>Converts JDBC calls into database-specific calls</td>
                    </tr>
                    <tr>
                        <td><strong>Type 3</strong></td>
                        <td>Network Protocol Driver</td>
                        <td>Uses middleware to convert JDBC calls</td>
                    </tr>
                    <tr>
                        <td><strong>Type 4</strong></td>
                        <td>Thin Driver (Pure Java)</td>
                        <td>Directly converts JDBC calls to database protocol (most common)</td>
                    </tr>
                </tbody>
            </table>

            <div class="callout tip">
                <div class="callout-title">üí° TIP</div>
                <p>Type 4 drivers are the most popular because they are pure Java, platform-independent, and don't
                    require any native libraries.</p>
            </div>
        </div>

        <!-- Section 3: JDBC Steps -->
        <div class="content-section">
            <h2>üìã Steps to Connect to Database using JDBC</h2>

            <h3>Step 1: Load the Driver</h3>
            <p>Register the JDBC driver with DriverManager.</p>
            <pre><code class="language-java">Class.forName("com.mysql.cj.jdbc.Driver");</code></pre>
            <p><strong>Note:</strong> In JDBC 4.0+, this step is automatic if the driver JAR is in the classpath.</p>

            <h3>Step 2: Establish Connection</h3>
            <p>Create a connection to the database using a connection URL.</p>
            <pre><code class="language-java">Connection con = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", 
    "username", 
    "password"
);</code></pre>

            <h3>Step 3: Create Statement</h3>
            <p>Create a Statement or PreparedStatement object.</p>
            <pre><code class="language-java">Statement stmt = con.createStatement();
// OR
PreparedStatement pstmt = con.prepareStatement("SELECT * FROM users WHERE id = ?");</code></pre>

            <h3>Step 4: Execute Query</h3>
            <p>Execute SQL queries using the statement object.</p>
            <pre><code class="language-java">ResultSet rs = stmt.executeQuery("SELECT * FROM users");
// OR for updates
int rowsAffected = stmt.executeUpdate("INSERT INTO users VALUES (1, 'John')");</code></pre>

            <h3>Step 5: Process Results</h3>
            <p>Iterate through the ResultSet to retrieve data.</p>
            <pre><code class="language-java">while(rs.next()) {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    System.out.println(id + " - " + name);
}</code></pre>

            <h3>Step 6: Close Resources</h3>
            <p>Always close ResultSet, Statement, and Connection to free resources.</p>
            <pre><code class="language-java">rs.close();
stmt.close();
con.close();</code></pre>

            <div class="callout warning">
                <div class="callout-title">‚ö†Ô∏è WARNING</div>
                <p>Always close database resources in a finally block or use try-with-resources to prevent resource
                    leaks!</p>
            </div>
        </div>

        <!-- Section 4: Types of Statements -->
        <div class="content-section">
            <h2>üìù Types of Statements</h2>

            <h3>1. Statement</h3>
            <p>
                <strong>Baby:</strong> Like writing a letter fresh every time.<br>
                <strong>Real-world:</strong> Typing a new email from scratch each time.<br>
                <strong>Technical:</strong> Used for executing simple SQL queries without parameters. Vulnerable to SQL
                injection.
            </p>
            <pre><code class="language-java">Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");</code></pre>

            <h3>2. PreparedStatement</h3>
            <p>
                <strong>Baby:</strong> Like having a template letter where you just fill in the blanks.<br>
                <strong>Real-world:</strong> A form where you fill in your name and address.<br>
                <strong>Technical:</strong> Pre-compiled SQL statement with parameters. Prevents SQL injection and is
                faster for repeated queries.
            </p>
            <pre><code class="language-java">PreparedStatement pstmt = con.prepareStatement("SELECT * FROM users WHERE id = ?");
pstmt.setInt(1, 101);
ResultSet rs = pstmt.executeQuery();</code></pre>

            <h3>3. CallableStatement</h3>
            <p>
                <strong>Baby:</strong> Like calling a special helper who does a complex job for you.<br>
                <strong>Real-world:</strong> Calling customer service to handle a complex request.<br>
                <strong>Technical:</strong> Used to execute stored procedures in the database.
            </p>
            <pre><code class="language-java">CallableStatement cstmt = con.prepareCall("{call getEmployeeDetails(?)}");
cstmt.setInt(1, 101);
ResultSet rs = cstmt.executeQuery();</code></pre>

            <div class="callout tip">
                <div class="callout-title">üí° BEST PRACTICE</div>
                <p>Always use PreparedStatement instead of Statement to prevent SQL injection attacks and improve
                    performance.</p>
            </div>
        </div>

        <!-- Section 5: CRUD Operations -->
        <div class="content-section">
            <h2>üîÑ CRUD Operations</h2>

            <h3>CREATE (Insert)</h3>
            <pre><code class="language-java">PreparedStatement pstmt = con.prepareStatement("INSERT INTO users(name, age) VALUES (?, ?)");
pstmt.setString(1, "Alice");
pstmt.setInt(2, 25);
int rows = pstmt.executeUpdate();
System.out.println(rows + " row(s) inserted");</code></pre>

            <h3>READ (Select)</h3>
            <pre><code class="language-java">PreparedStatement pstmt = con.prepareStatement("SELECT * FROM users WHERE age > ?");
pstmt.setInt(1, 18);
ResultSet rs = pstmt.executeQuery();
while(rs.next()) {
    System.out.println(rs.getString("name") + " - " + rs.getInt("age"));
}</code></pre>

            <h3>UPDATE</h3>
            <pre><code class="language-java">PreparedStatement pstmt = con.prepareStatement("UPDATE users SET age = ? WHERE name = ?");
pstmt.setInt(1, 26);
pstmt.setString(2, "Alice");
int rows = pstmt.executeUpdate();
System.out.println(rows + " row(s) updated");</code></pre>

            <h3>DELETE</h3>
            <pre><code class="language-java">PreparedStatement pstmt = con.prepareStatement("DELETE FROM users WHERE id = ?");
pstmt.setInt(1, 101);
int rows = pstmt.executeUpdate();
System.out.println(rows + " row(s) deleted");</code></pre>

            <div class="callout example">
                <div class="callout-title">üìñ EXAMPLE</div>
                <p>Notice how all CRUD operations use PreparedStatement with placeholders (?) to safely pass
                    parameters.</p>
            </div>
        </div>

        <!-- Section 6: SQL Injection Prevention -->
        <div class="content-section">
            <h2>üõ°Ô∏è Preventing SQL Injection</h2>

            <h3>What is SQL Injection?</h3>
            <p>
                <strong>Baby:</strong> Like a bad person tricking the guard by saying the wrong password.<br>
                <strong>Real-world:</strong> A hacker typing special characters in a login form to access unauthorized
                data.<br>
                <strong>Technical:</strong> An attack where malicious SQL code is inserted into application queries to
                manipulate the database.
            </p>

            <h3>Vulnerable Code (Using Statement)</h3>
            <pre><code class="language-java">String username = request.getParameter("username"); // User input: admin' OR '1'='1
String query = "SELECT * FROM users WHERE username = '" + username + "'";
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery(query);
// Query becomes: SELECT * FROM users WHERE username = 'admin' OR '1'='1'
// This returns ALL users!</code></pre>

            <h3>Safe Code (Using PreparedStatement)</h3>
            <pre><code class="language-java">String username = request.getParameter("username");
PreparedStatement pstmt = con.prepareStatement("SELECT * FROM users WHERE username = ?");
pstmt.setString(1, username); // Safely escapes special characters
ResultSet rs = pstmt.executeQuery();
// Even if username is "admin' OR '1'='1", it's treated as a literal string</code></pre>

            <div class="callout warning">
                <div class="callout-title">‚ö†Ô∏è CRITICAL</div>
                <p>Never concatenate user input directly into SQL queries! Always use PreparedStatement with
                    parameterized queries.</p>
            </div>
        </div>

        <!-- Section 7: Transactions -->
        <div class="content-section">
            <h2>üí≥ Transactions in JDBC</h2>

            <h3>What is a Transaction?</h3>
            <p>
                <strong>Baby:</strong> Like doing multiple things together‚Äîif one fails, undo everything!<br>
                <strong>Real-world:</strong> Transferring money from Account A to Account B. If the debit succeeds but
                credit fails, rollback the debit.<br>
                <strong>Technical:</strong> A transaction is a set of operations that execute as a single unit. Either
                all succeed (commit) or all fail (rollback).
            </p>

            <h3>ACID Properties</h3>
            <ul>
                <li><strong>Atomicity:</strong> All or nothing</li>
                <li><strong>Consistency:</strong> Database remains in a valid state</li>
                <li><strong>Isolation:</strong> Transactions don't interfere with each other</li>
                <li><strong>Durability:</strong> Once committed, changes are permanent</li>
            </ul>

            <h3>Transaction Management in JDBC</h3>
            <pre><code class="language-java">try {
    con.setAutoCommit(false); // Disable auto-commit
    
    // Operation 1: Debit from Account A
    PreparedStatement pstmt1 = con.prepareStatement("UPDATE accounts SET balance = balance - ? WHERE id = ?");
    pstmt1.setDouble(1, 500.0);
    pstmt1.setInt(2, 1);
    pstmt1.executeUpdate();
    
    // Operation 2: Credit to Account B
    PreparedStatement pstmt2 = con.prepareStatement("UPDATE accounts SET balance = balance + ? WHERE id = ?");
    pstmt2.setDouble(1, 500.0);
    pstmt2.setInt(2, 2);
    pstmt2.executeUpdate();
    
    con.commit(); // Commit if both succeed
    System.out.println("Transaction successful!");
    
} catch (SQLException e) {
    con.rollback(); // Rollback if any operation fails
    System.out.println("Transaction failed! Rolled back.");
} finally {
    con.setAutoCommit(true); // Restore auto-commit
}</code></pre>

            <div class="callout note">
                <div class="callout-title">üìö NOTE</div>
                <p>By default, JDBC connections have auto-commit enabled. Each SQL statement is treated as a
                    transaction and automatically committed.</p>
            </div>
        </div>

        <!-- Section 8: Batch Processing -->
        <div class="content-section">
            <h2>üì¶ Batch Processing</h2>

            <h3>What is Batch Processing?</h3>
            <p>
                <strong>Baby:</strong> Instead of mailing one letter at a time, you collect many letters and mail them
                all together!<br>
                <strong>Real-world:</strong> Uploading 1000 student records at once instead of one by one.<br>
                <strong>Technical:</strong> Grouping multiple SQL statements and sending them to the database in a
                single network call for better performance.
            </p>

            <h3>Example</h3>
            <pre><code class="language-java">PreparedStatement pstmt = con.prepareStatement("INSERT INTO students(name, age) VALUES (?, ?)");

// Add multiple batches
pstmt.setString(1, "Alice");
pstmt.setInt(2, 20);
pstmt.addBatch();

pstmt.setString(1, "Bob");
pstmt.setInt(2, 22);
pstmt.addBatch();

pstmt.setString(1, "Charlie");
pstmt.setInt(2, 21);
pstmt.addBatch();

// Execute all at once
int[] results = pstmt.executeBatch();
System.out.println("Inserted " + results.length + " records");</code></pre>

            <div class="callout tip">
                <div class="callout-title">üí° TIP</div>
                <p>Batch processing significantly improves performance when inserting/updating large amounts of data.
                </p>
            </div>
        </div>

        <!-- Section 9: Stored Procedures -->
        <div class="content-section">
            <h2>üóÑÔ∏è Calling Stored Procedures</h2>

            <h3>What is a Stored Procedure?</h3>
            <p>
                <strong>Baby:</strong> Like a recipe saved in a cookbook that you can use anytime.<br>
                <strong>Real-world:</strong> A pre-written script at the bank that calculates interest
                automatically.<br>
                <strong>Technical:</strong> Pre-compiled SQL code stored in the database that can be executed by calling
                its name.
            </p>

            <h3>Example</h3>
            <pre><code class="language-java">// Stored Procedure in Database: CREATE PROCEDURE getEmployeeById(IN empId INT)

CallableStatement cstmt = con.prepareCall("{call getEmployeeById(?)}");
cstmt.setInt(1, 101);
ResultSet rs = cstmt.executeQuery();

while(rs.next()) {
    System.out.println(rs.getString("name"));
}</code></pre>

            <h3>Stored Procedure with OUT Parameter</h3>
            <pre><code class="language-java">// Stored Procedure: CREATE PROCEDURE getEmployeeCount(OUT total INT)

CallableStatement cstmt = con.prepareCall("{call getEmployeeCount(?)}");
cstmt.registerOutParameter(1, Types.INTEGER);
cstmt.execute();

int count = cstmt.getInt(1);
System.out.println("Total Employees: " + count);</code></pre>
        </div>

        <!-- Section 10: Different Databases -->
        <div class="content-section">
            <h2>üóÉÔ∏è JDBC with Different Databases</h2>

            <h3>MySQL</h3>
            <pre><code class="language-java">Class.forName("com.mysql.cj.jdbc.Driver");
Connection con = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "root", "password"
);</code></pre>

            <h3>PostgreSQL</h3>
            <pre><code class="language-java">Class.forName("org.postgresql.Driver");
Connection con = DriverManager.getConnection(
    "jdbc:postgresql://localhost:5432/mydb", "postgres", "password"
);</code></pre>

            <h3>Oracle</h3>
            <pre><code class="language-java">Class.forName("oracle.jdbc.driver.OracleDriver");
Connection con = DriverManager.getConnection(
    "jdbc:oracle:thin:@localhost:1521:xe", "system", "password"
);</code></pre>

            <h3>SQL Server</h3>
            <pre><code class="language-java">Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
Connection con = DriverManager.getConnection(
    "jdbc:sqlserver://localhost:1433;databaseName=mydb", "sa", "password"
);</code></pre>

            <div class="callout note">
                <div class="callout-title">üìö NOTE</div>
                <p>The connection URL format varies by database, but the JDBC code remains largely the same!</p>
            </div>
        </div>

        <!-- Section 11: Common Mistakes -->
        <div class="content-section">
            <h2>‚ùå Common Mistakes</h2>

            <div class="callout warning">
                <div class="callout-title">‚ö†Ô∏è Not Closing Connections</div>
                <p>Forgetting to close connections leads to resource leaks and eventually "Too many connections" errors.
                </p>
            </div>

            <ul>
                <li><strong>Forgetting to commit:</strong> When auto-commit is disabled, changes won't persist unless
                    you call commit().</li>
                <li><strong>Hardcoding SQL queries:</strong> Makes code difficult to maintain. Use constants or
                    configuration files.</li>
                <li><strong>Using Statement instead of PreparedStatement:</strong> Opens door to SQL injection attacks.
                </li>
                <li><strong>Not handling SQLException properly:</strong> Always catch and log exceptions with proper
                    error messages.</li>
                <li><strong>Opening too many connections:</strong> Use connection pooling for better resource
                    management.</li>
                <li><strong>Ignoring ResultSet position:</strong> Always call rs.next() before accessing data.</li>
            </ul>
        </div>

        <!-- Section 12: Best Practices -->
        <div class="content-section">
            <h2>‚úÖ Best Practices</h2>

            <div class="callout tip">
                <div class="callout-title">üí° Use try-with-resources</div>
                <p>Automatically closes resources even if exceptions occur.</p>
                <pre><code class="language-java">try (Connection con = DriverManager.getConnection(url, user, pass);
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM users");
     ResultSet rs = pstmt.executeQuery()) {
    
    while(rs.next()) {
        // Process results
    }
} catch (SQLException e) {
    e.printStackTrace();
}
// Resources automatically closed!</code></pre>
            </div>

            <ul>
                <li><strong>Use Connection Pooling:</strong> Libraries like HikariCP, Apache DBCP maintain a pool of
                    reusable connections.</li>
                <li><strong>Always use PreparedStatement:</strong> Prevents SQL injection and improves performance.</li>
                <li><strong>Handle exceptions properly:</strong> Log errors with context, don't just print stack
                    traces.</li>
                <li><strong>Use transactions for related operations:</strong> Ensure data consistency.</li>
                <li><strong>Close resources in reverse order:</strong> ResultSet ‚Üí Statement ‚Üí Connection.</li>
                <li><strong>Don't store passwords in code:</strong> Use environment variables or configuration files.
                </li>
                <li><strong>Use batch processing for bulk operations:</strong> Significantly improves performance.</li>
                <li><strong>Set appropriate timeout values:</strong> Prevent hanging connections.</li>
            </ul>

            <div class="callout example">
                <div class="callout-title">üìñ EXAMPLE: Connection Pooling with HikariCP</div>
                <pre><code class="language-java">HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
config.setUsername("root");
config.setPassword("password");
config.setMaximumPoolSize(10);

HikariDataSource dataSource = new HikariDataSource(config);
Connection con = dataSource.getConnection(); // Reuses existing connections!</code></pre>
            </div>
        </div>

        <!-- Final Note -->
        <div class="content-section">
            <div class="callout note">
                <div class="callout-title">üéâ Congratulations!</div>
                <p>You've completed the theory for Java JDBC in Depth! You now understand how to connect Java
                    applications to databases, execute queries safely, manage transactions, and follow best practices.
                </p>
                <p><strong>Next Step:</strong> Practice with real code examples in the Programs section!</p>
            </div>
        </div>

        <!-- Navigation -->
        <div class="next-topic">
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <a href="../programs/jdbc.html" class="btn btn-primary">üíª View Programs</a>
                <a href="../mcq/jdbc.html" class="btn btn-success">‚úÖ Take Quiz</a>
                <a href="../index.html" class="btn btn-secondary">üè† Back to Home</a>
            </div>
            <div class="callout note" style="margin-top: 2rem;">
                <div class="callout-title">üéâ Final Topic Complete!</div>
                <p><strong>Congratulations!</strong> You've completed all 12 core Java topics. Advanced topics coming
                    soon!</p>
            </div>
        </div>
    </div>

    <script src="../assets/js/mcq.js"></script>
</body>

</html>