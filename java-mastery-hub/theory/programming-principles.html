<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Principles (The Philosophy) - Java Mastery Hub</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <!-- Header -->
    <header>
        <div class="header-content">
            <div class="logo">
                <span class="logo-icon">â˜•</span>
                <span>Java Mastery Hub</span>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Content Header -->
        <div class="content-header">
            <h1>Programming Principles (The Philosophy)</h1>
            <div class="breadcrumb">
                <a href="../index.html">Home</a>
                <span>/</span>
                <span>Theory</span>
                <span>/</span>
                <span>Programming Principles</span>
            </div>
        </div>

        <!-- Section 1: Introduction -->
        <div class="content-section">
            <h2>ğŸ¯ Introduction: Why Programming Principles Matter</h2>

            <h3>Level 1: Beginner-Friendly Explanation (Like Explaining to a Baby)</h3>
            <p>
                Imagine you're building with LEGO blocks. If you just throw blocks together randomly, your building
                will be messy and fall apart easily. But if you follow some <strong>simple rules</strong>â€”like putting
                big blocks at the bottom and connecting pieces properlyâ€”your building will be strong and beautiful!
            </p>
            <p>
                Programming principles are like those LEGO rules. They help you write code that is
                <strong>strong</strong>, <strong>easy to understand</strong>, and <strong>easy to change</strong> later.
            </p>

            <h3>Level 2: Real-World Analogy</h3>
            <p>
                Think of building a house:
            </p>
            <ul>
                <li><strong>Without principles:</strong> You build rooms randomly, mix plumbing with electrical wiring,
                    and use weak materials. The house might stand, but it's dangerous, hard to repair, and will
                    collapse easily.</li>
                <li><strong>With principles:</strong> You follow building codes, separate concerns (plumbing separate
                    from electrical), use quality materials, and design for future additions. The house is safe,
                    maintainable, and can grow with your needs.</li>
            </ul>
            <p>
                Programming principles are the "building codes" of software development. They ensure your code is
                robust, maintainable, and scalable.
            </p>

            <h3>Level 3: Technical Deep-Dive</h3>
            <p>
                Programming principles are fundamental guidelines that help developers write high-quality code.
                They address critical software engineering concerns:
            </p>
            <ul>
                <li><strong>Maintainability:</strong> Code that's easy to understand and modify</li>
                <li><strong>Scalability:</strong> Systems that can grow without complete rewrites</li>
                <li><strong>Reusability:</strong> Components that can be used in multiple contexts</li>
                <li><strong>Testability:</strong> Code that can be easily tested</li>
                <li><strong>Flexibility:</strong> Systems that adapt to changing requirements</li>
            </ul>

            <div class="callout note">
                <div class="callout-title">ğŸ“š NOTE</div>
                <p>These principles aren't strict rulesâ€”they're guidelines. Sometimes you'll need to balance
                    trade-offs. The key is understanding <em>why</em> each principle exists and when to apply it.</p>
            </div>
        </div>

        <!-- Section 2: Core Design Principles -->
        <div class="content-section">
            <h2>ğŸ§© Core Design Principles</h2>

            <h3>1. DRY (Don't Repeat Yourself)</h3>
            <p>
                <strong>Baby:</strong> If you know how to tie your shoes, you don't need someone to teach you every
                single time. You learned it once!<br>
                <strong>Real-world:</strong> Like having a recipe card instead of writing the same recipe in multiple
                cookbooks.<br>
                <strong>Technical:</strong> Every piece of knowledge should have a single, unambiguous representation
                in the system.
            </p>
            <pre><code class="language-java">// BAD - Repeated code
public void printUserReport(User user) {
    System.out.println("Name: " + user.getName());
    System.out.println("Email: " + user.getEmail());
}

public void printAdminReport(User admin) {
    System.out.println("Name: " + admin.getName());
    System.out.println("Email: " + admin.getEmail());
}

// GOOD - DRY principle
public void printUserInfo(User user) {
    System.out.println("Name: " + user.getName());
    System.out.println("Email: " + user.getEmail());
}</code></pre>

            <div class="callout tip">
                <div class="callout-title">ğŸ’¡ TIP</div>
                <p>If you find yourself copying and pasting code, stop! Extract it into a reusable method or class.</p>
            </div>

            <h3>2. KISS (Keep It Simple, Stupid)</h3>
            <p>
                <strong>Baby:</strong> Use a spoon to eat soup, not a complicated machine!<br>
                <strong>Real-world:</strong> Like using a simple door lock instead of a fingerprint scanner with facial
                recognition for your bedroom.<br>
                <strong>Technical:</strong> Simplicity should be a key goal in design. Avoid unnecessary complexity.
            </p>
            <pre><code class="language-java">// BAD - Overcomplicated
public boolean isEven(int number) {
    return (number % 2 == 0) ? true : false;
}

// GOOD - Simple and clear
public boolean isEven(int number) {
    return number % 2 == 0;
}</code></pre>

            <h3>3. YAGNI (You Aren't Gonna Need It)</h3>
            <p>
                <strong>Baby:</strong> Don't pack winter clothes for a summer vacation!<br>
                <strong>Real-world:</strong> Like not buying a 10-bedroom house when you live alone "just in
                case."<br>
                <strong>Technical:</strong> Don't add functionality until it's actually needed. Avoid speculative
                generality.
            </p>

            <div class="callout warning">
                <div class="callout-title">âš ï¸ WARNING</div>
                <p>Over-engineering is a common trap. Build what you need now, not what you <em>might</em> need in the
                    future. You can always add features later when requirements are clear.</p>
            </div>

            <h3>4. Separation of Concerns (SoC)</h3>
            <p>
                <strong>Baby:</strong> Keep your toys in the toy box, books on the bookshelf, and clothes in the
                closet.<br>
                <strong>Real-world:</strong> Like having separate departments in a company: HR, Finance, Engineering,
                Marketing.<br>
                <strong>Technical:</strong> Different concerns should be separated into distinct sections or modules.
            </p>
            <pre><code class="language-java">// BAD - Mixed concerns
public class User {
    private String name;
    
    public void saveToDatabase() { /* database logic */ }
    public void sendEmail() { /* email logic */ }
    public void generatePDF() { /* PDF logic */ }
}

// GOOD - Separated concerns
public class User {
    private String name;
    // Only user data and behavior
}

public class UserRepository {
    public void save(User user) { /* database logic */ }
}

public class EmailService {
    public void sendWelcomeEmail(User user) { /* email logic */ }
}</code></pre>

            <h3>5. Coupling vs Cohesion</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Coupling (Bad when High)</th>
                        <th>Cohesion (Good when High)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>How much one class depends on another</td>
                        <td>How focused a class is on a single purpose</td>
                    </tr>
                    <tr>
                        <td>Goal: <strong>Low coupling</strong> (loose dependencies)</td>
                        <td>Goal: <strong>High cohesion</strong> (focused responsibility)</td>
                    </tr>
                    <tr>
                        <td>Like tangled headphone wiresâ€”hard to separate</td>
                        <td>Like a Swiss Army knifeâ€”all tools serve camping</td>
                    </tr>
                    <tr>
                        <td>Changes in one class break others</td>
                        <td>All methods work toward the same goal</td>
                    </tr>
                </tbody>
            </table>

            <div class="callout example">
                <div class="callout-title">ğŸ’¡ EXAMPLE</div>
                <p><strong>High Coupling (Bad):</strong> Class A directly creates instances of Class B, C, and D.
                    Changing B breaks A.</p>
                <p><strong>Low Coupling (Good):</strong> Class A depends on interfaces. Implementations can change
                    without affecting A.</p>
            </div>
        </div>

        <!-- Section 3: SOLID Principles -->
        <div class="content-section">
            <h2>ğŸ›ï¸ S.O.L.I.D Principles</h2>
            <p>
                SOLID is an acronym for five design principles that make software designs more understandable,
                flexible, and maintainable. These principles were introduced by Robert C. Martin (Uncle Bob).
            </p>

            <h3>S - Single Responsibility Principle (SRP)</h3>
            <p><strong>Definition:</strong> A class should have only one reason to change.</p>

            <p>
                <strong>Baby:</strong> A spoon is for eating, not for cutting. Each tool has one job!<br>
                <strong>Real-world:</strong> A chef cooks, a waiter serves, a cashier handles payment. Each person has
                one clear responsibility.<br>
                <strong>Technical:</strong> Each class should have only one responsibility or job. If a class does too
                many things, changes to one feature can break others.
            </p>

            <pre><code class="language-java">// BAD - Multiple responsibilities
public class Employee {
    private String name;
    private double salary;
    
    public void calculatePay() { /* payroll logic */ }
    public void saveToDatabase() { /* database logic */ }
    public void generateReport() { /* reporting logic */ }
}

// GOOD - Single responsibility
public class Employee {
    private String name;
    private double salary;
    
    // Only employee data and basic behavior
    public String getName() { return name; }
    public double getSalary() { return salary; }
}

public class PayrollCalculator {
    public double calculatePay(Employee emp) { /* payroll logic */ }
}

public class EmployeeRepository {
    public void save(Employee emp) { /* database logic */ }
}

public class EmployeeReportGenerator {
    public String generateReport(Employee emp) { /* reporting logic */ }
}</code></pre>

            <div class="callout tip">
                <div class="callout-title">ğŸ’¡ INDUSTRY BEST PRACTICE</div>
                <p>Ask yourself: "What is the one reason this class would need to change?" If you can think of multiple
                    reasons, it's doing too much.</p>
            </div>

            <div class="callout warning">
                <div class="callout-title">âš ï¸ COMMON MISTAKE</div>
                <p>Creating "God classes" that do everything. These become maintenance nightmares as they grow.</p>
            </div>

            <h3>O - Open/Closed Principle (OCP)</h3>
            <p><strong>Definition:</strong> Software entities should be open for extension but closed for modification.
            </p>

            <p>
                <strong>Baby:</strong> You can add new toys to your toy box without breaking the old ones!<br>
                <strong>Real-world:</strong> Like a smartphone with appsâ€”you can add new apps without changing the
                phone's operating system.<br>
                <strong>Technical:</strong> You should be able to add new functionality without modifying existing
                code. Use abstraction and polymorphism.
            </p>

            <pre><code class="language-java">// BAD - Closed for extension, must modify for new shapes
public class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        }
        // Must modify this method to add new shapes!
        return 0;
    }
}

// GOOD - Open for extension via polymorphism
public interface Shape {
    double calculateArea();
}

public class Circle implements Shape {
    private double radius;
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle implements Shape {
    private double width, height;
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

// Can add new shapes without modifying existing code!
public class Triangle implements Shape {
    private double base, height;
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}</code></pre>

            <div class="callout example">
                <div class="callout-title">ğŸ’¡ EXAMPLE</div>
                <p>Think of USB ports. You can plug in new USB devices (extension) without modifying the port itself
                    (closed for modification).</p>
            </div>

            <h3>L - Liskov Substitution Principle (LSP)</h3>
            <p><strong>Definition:</strong> Objects of a superclass should be replaceable with objects of a subclass
                without breaking the application.</p>

            <p>
                <strong>Baby:</strong> If someone asks for a "vehicle," you can give them a car, bike, or truckâ€”all
                work!<br>
                <strong>Real-world:</strong> Like replacing a regular battery with a rechargeable oneâ€”both work in your
                remote.<br>
                <strong>Technical:</strong> Subtypes must be substitutable for their base types without altering
                program correctness.
            </p>

            <pre><code class="language-java">// BAD - Violates LSP
public class Bird {
    public void fly() {
        System.out.println("Flying...");
    }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
        // This breaks the contract! Code expecting Bird.fly() will fail
    }
}

// GOOD - Respects LSP
public abstract class Bird {
    public abstract void move();
}

public class Sparrow extends Bird {
    @Override
    public void move() {
        System.out.println("Flying...");
    }
}

public class Penguin extends Bird {
    @Override
    public void move() {
        System.out.println("Swimming...");
    }
}

// Now both can be used interchangeably as Bird
public void makeBirdMove(Bird bird) {
    bird.move(); // Works for all birds!
}</code></pre>

            <div class="callout warning">
                <div class="callout-title">âš ï¸ COMMON MISTAKE</div>
                <p>Creating inheritance hierarchies based on "is-a" relationships that don't hold behaviorally. Just
                    because a penguin "is a" bird doesn't mean it should inherit flying behavior.</p>
            </div>

            <h3>I - Interface Segregation Principle (ISP)</h3>
            <p><strong>Definition:</strong> Clients should not be forced to depend on interfaces they don't use.</p>

            <p>
                <strong>Baby:</strong> Don't force someone to eat vegetables if they only want dessert!<br>
                <strong>Real-world:</strong> Like a TV remote with only the buttons you need, not 100 buttons you never
                use.<br>
                <strong>Technical:</strong> Create specific, focused interfaces rather than one large, general-purpose
                interface.
            </p>

            <pre><code class="language-java">// BAD - Fat interface
public interface Worker {
    void work();
    void eat();
    void sleep();
}

public class Robot implements Worker {
    @Override
    public void work() { /* robots work */ }
    
    @Override
    public void eat() { 
        // Robots don't eat! Forced to implement unnecessary method
        throw new UnsupportedOperationException();
    }
    
    @Override
    public void sleep() { 
        // Robots don't sleep!
        throw new UnsupportedOperationException();
    }
}

// GOOD - Segregated interfaces
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public interface Sleepable {
    void sleep();
}

public class Human implements Workable, Eatable, Sleepable {
    @Override
    public void work() { /* work */ }
    @Override
    public void eat() { /* eat */ }
    @Override
    public void sleep() { /* sleep */ }
}

public class Robot implements Workable {
    @Override
    public void work() { /* work */ }
    // Only implements what it needs!
}</code></pre>

            <div class="callout tip">
                <div class="callout-title">ğŸ’¡ INDUSTRY BEST PRACTICE</div>
                <p>Prefer many small, specific interfaces over one large interface. This is also known as "role
                    interfaces."</p>
            </div>

            <h3>D - Dependency Inversion Principle (DIP)</h3>
            <p><strong>Definition:</strong> High-level modules should not depend on low-level modules. Both should
                depend on abstractions.</p>

            <p>
                <strong>Baby:</strong> You don't care if your toy car has batteries or a wind-up keyâ€”you just want it
                to move!<br>
                <strong>Real-world:</strong> Like a power outletâ€”you don't care what device plugs in, as long as it
                follows the plug standard.<br>
                <strong>Technical:</strong> Depend on abstractions (interfaces/abstract classes), not concrete
                implementations. This decouples your code.
            </p>

            <pre><code class="language-java">// BAD - High-level depends on low-level
public class MySQLDatabase {
    public void save(String data) {
        System.out.println("Saving to MySQL: " + data);
    }
}

public class UserService {
    private MySQLDatabase database = new MySQLDatabase();
    // Tightly coupled to MySQL! Can't switch databases
    
    public void saveUser(String userData) {
        database.save(userData);
    }
}

// GOOD - Both depend on abstraction
public interface Database {
    void save(String data);
}

public class MySQLDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("Saving to MySQL: " + data);
    }
}

public class MongoDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("Saving to MongoDB: " + data);
    }
}

public class UserService {
    private Database database; // Depends on abstraction!
    
    // Dependency injection via constructor
    public UserService(Database database) {
        this.database = database;
    }
    
    public void saveUser(String userData) {
        database.save(userData);
        // Can work with ANY database implementation!
    }
}</code></pre>

            <div class="callout example">
                <div class="callout-title">ğŸ’¡ EXAMPLE</div>
                <p>This is the foundation of Dependency Injection frameworks like Spring. You define what you need
                    (interface), and the framework provides the implementation.</p>
            </div>

            <div class="callout note">
                <div class="callout-title">ğŸ“š SOLID SUMMARY</div>
                <p><strong>S</strong>ingle Responsibility: One class, one job<br>
                    <strong>O</strong>pen/Closed: Extend, don't modify<br>
                    <strong>L</strong>iskov Substitution: Subtypes must be substitutable<br>
                    <strong>I</strong>nterface Segregation: Small, focused interfaces<br>
                    <strong>D</strong>ependency Inversion: Depend on abstractions, not concretions
                </p>
            </div>
        </div>

        <!-- Section 4: Singleton Pattern -->
        <div class="content-section">
            <h2>ğŸ‘‘ The Singleton Pattern (Deep Dive)</h2>

            <h3>What is Singleton?</h3>
            <p>
                <strong>Baby:</strong> Like having only ONE principal in a schoolâ€”not two or three!<br>
                <strong>Real-world:</strong> Like a country having only one president at a time.<br>
                <strong>Technical:</strong> A design pattern that ensures a class has only one instance and provides a
                global point of access to it.
            </p>

            <h3>When to Use Singleton</h3>
            <ul>
                <li><strong>Configuration Management:</strong> One central config object for the entire application</li>
                <li><strong>Logging:</strong> Single logger instance to avoid file conflicts</li>
                <li><strong>Database Connection Pool:</strong> Manage connections centrally</li>
                <li><strong>Cache:</strong> Single cache instance shared across the application</li>
            </ul>

            <h3>When NOT to Use Singleton</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ WARNING</div>
                <p>Singletons are often overused! Avoid them when:</p>
                <ul>
                    <li>You need multiple instances in testing</li>
                    <li>The class maintains state that could cause issues in multi-threaded environments</li>
                    <li>It makes your code harder to test (hidden dependencies)</li>
                    <li>You're using it just to avoid passing parameters</li>
                </ul>
            </div>

            <h3>Types of Singleton Implementation</h3>

            <h4>1. Eager Initialization</h4>
            <pre><code class="language-java">public class EagerSingleton {
    // Instance created at class loading time
    private static final EagerSingleton instance = new EagerSingleton();
    
    private EagerSingleton() {
        // Private constructor prevents instantiation
    }
    
    public static EagerSingleton getInstance() {
        return instance;
    }
}

// Pros: Simple, thread-safe
// Cons: Instance created even if never used (wastes memory)</code></pre>

            <h4>2. Lazy Initialization</h4>
            <pre><code class="language-java">public class LazySingleton {
    private static LazySingleton instance;
    
    private LazySingleton() {}
    
    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton(); // Created only when needed
        }
        return instance;
    }
}

// Pros: Instance created only when needed
// Cons: NOT thread-safe! Multiple threads can create multiple instances</code></pre>

            <h4>3. Thread-Safe Singleton (Synchronized)</h4>
            <pre><code class="language-java">public class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;
    
    private ThreadSafeSingleton() {}
    
    public static synchronized ThreadSafeSingleton getInstance() {
        if (instance == null) {
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
}

// Pros: Thread-safe
// Cons: Synchronized method is slow (performance hit on every call)</code></pre>

            <h4>4. Double-Checked Locking (Best Practice)</h4>
            <pre><code class="language-java">public class DoubleCheckedSingleton {
    private static volatile DoubleCheckedSingleton instance;
    
    private DoubleCheckedSingleton() {}
    
    public static DoubleCheckedSingleton getInstance() {
        if (instance == null) { // First check (no locking)
            synchronized (DoubleCheckedSingleton.class) {
                if (instance == null) { // Second check (with locking)
                    instance = new DoubleCheckedSingleton();
                }
            }
        }
        return instance;
    }
}

// Pros: Thread-safe, better performance (synchronization only on first creation)
// Cons: More complex code</code></pre>

            <h4>5. Bill Pugh Singleton (Recommended)</h4>
            <pre><code class="language-java">public class BillPughSingleton {
    
    private BillPughSingleton() {}
    
    // Inner static helper class
    private static class SingletonHelper {
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }
    
    public static BillPughSingleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}

// Pros: Thread-safe, lazy initialization, no synchronization overhead
// How: Inner class is loaded only when getInstance() is called
// This is the BEST approach for most cases!</code></pre>

            <h3>Real-World Example: Logger</h3>
            <pre><code class="language-java">public class Logger {
    private static volatile Logger instance;
    
    private Logger() {
        // Initialize logging configuration
    }
    
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) {
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }
    
    public void log(String message) {
        System.out.println("[LOG] " + message);
    }
}

// Usage
Logger.getInstance().log("Application started");
Logger.getInstance().log("User logged in");</code></pre>

            <h3>Memory Impact</h3>
            <p>
                Singletons remain in memory for the entire application lifetime. This is fine for lightweight objects
                like configuration or loggers, but be cautious with heavy objects that hold large amounts of data.
            </p>

            <div class="callout tip">
                <div class="callout-title">ğŸ’¡ MODERN ALTERNATIVE</div>
                <p>In modern Java applications (especially with Spring), prefer Dependency Injection over Singleton
                    pattern. Let the framework manage single instances for you!</p>
            </div>
        </div>

        <!-- Section 5: MVC Architecture -->
        <div class="content-section">
            <h2>ğŸ¨ MVC Architecture (Model-View-Controller)</h2>

            <h3>What is MVC?</h3>
            <p>
                <strong>Baby:</strong> Like a restaurant: Chef (Model) makes food, Waiter (Controller) takes orders,
                Menu (View) shows what's available!<br>
                <strong>Real-world:</strong> Like a theater: Actors (Model) perform, Director (Controller) manages,
                Audience (View) watches.<br>
                <strong>Technical:</strong> An architectural pattern that separates an application into three
                interconnected components.
            </p>

            <h3>The Three Components</h3>

            <h4>Model (Data + Business Logic)</h4>
            <ul>
                <li>Represents the data and business rules</li>
                <li>Manages the state of the application</li>
                <li>Independent of the user interface</li>
                <li>Notifies observers when data changes</li>
            </ul>

            <h4>View (User Interface)</h4>
            <ul>
                <li>Displays data to the user</li>
                <li>Presents the model in a specific format</li>
                <li>Multiple views can exist for the same model</li>
                <li>Should contain minimal logic (only presentation)</li>
            </ul>

            <h4>Controller (Request Handler)</h4>
            <ul>
                <li>Handles user input and requests</li>
                <li>Updates the model based on user actions</li>
                <li>Selects the appropriate view to display</li>
                <li>Acts as the intermediary between Model and View</li>
            </ul>

            <h3>MVC Flow Diagram</h3>
            <pre
                style="background: var(--bg-hover); padding: var(--spacing-md); border-radius: var(--radius-sm); border-left: 4px solid var(--primary);">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ 1. Interacts (clicks, types)
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Controller  â”‚ â—„â”€â”€â”€ Handles user input
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 2. Updates
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Model     â”‚ â—„â”€â”€â”€ Business logic & data
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 3. Notifies of changes
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     View     â”‚ â—„â”€â”€â”€ Displays data
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 4. Renders
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User   â”‚ â—„â”€â”€â”€ Sees updated UI
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </pre>

            <h3>Why MVC is Used in Web Applications</h3>
            <ul>
                <li><strong>Separation of Concerns:</strong> Each component has a distinct responsibility</li>
                <li><strong>Parallel Development:</strong> Frontend and backend teams can work independently</li>
                <li><strong>Reusability:</strong> Same model can be used with different views (web, mobile, API)</li>
                <li><strong>Testability:</strong> Each component can be tested in isolation</li>
                <li><strong>Maintainability:</strong> Changes in one component don't affect others</li>
            </ul>

            <h3>Example: Java Spring MVC</h3>
            <pre><code class="language-java">// Model
public class User {
    private Long id;
    private String name;
    private String email;
    
    // Getters and setters
}

// Controller
@Controller
public class UserController {
    
    @Autowired
    private UserService userService; // Business logic
    
    @GetMapping("/users")
    public String listUsers(Model model) {
        List<User> users = userService.getAllUsers();
        model.addAttribute("users", users);
        return "userList"; // View name
    }
    
    @PostMapping("/users")
    public String createUser(@ModelAttribute User user) {
        userService.save(user);
        return "redirect:/users";
    }
}

// View (userList.jsp or Thymeleaf template)
// Displays the list of users from the model</code></pre>

            <div class="callout example">
                <div class="callout-title">ğŸ’¡ REAL-WORLD EXAMPLE</div>
                <p>Think of an e-commerce website:</p>
                <ul>
                    <li><strong>Model:</strong> Product data, shopping cart, order processing logic</li>
                    <li><strong>View:</strong> Product listing page, cart page, checkout page</li>
                    <li><strong>Controller:</strong> Handles "Add to Cart," "Checkout," "Search Products" actions</li>
                </ul>
            </div>

            <div class="callout tip">
                <div class="callout-title">ğŸ’¡ TIP</div>
                <p>Keep your controllers thin! They should delegate business logic to services/models, not implement it
                    themselves.</p>
            </div>
        </div>

        <!-- Section 6: Additional Design Patterns -->
        <div class="content-section">
            <h2>ğŸ­ Additional Design Patterns (Introduction)</h2>
            <p>
                Design patterns are reusable solutions to common problems in software design. Here are brief
                introductions to four important patterns. (Detailed coverage will be in advanced architecture topics.)
            </p>

            <h3>1. Factory Pattern</h3>
            <p>
                <strong>Purpose:</strong> Create objects without specifying the exact class to create.<br>
                <strong>Analogy:</strong> Like ordering a pizzaâ€”you don't make it yourself, you ask the pizza factory
                (restaurant).<br>
                <strong>Use Case:</strong> When object creation logic is complex or when you want to decouple object
                creation from usage.
            </p>
            <pre><code class="language-java">// Simple Factory example
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    public void draw() { System.out.println("Drawing Circle"); }
}

public class Rectangle implements Shape {
    public void draw() { System.out.println("Drawing Rectangle"); }
}

public class ShapeFactory {
    public static Shape getShape(String type) {
        if (type.equals("CIRCLE")) return new Circle();
        if (type.equals("RECTANGLE")) return new Rectangle();
        return null;
    }
}

// Usage
Shape shape = ShapeFactory.getShape("CIRCLE");
shape.draw();</code></pre>

            <h3>2. Strategy Pattern</h3>
            <p>
                <strong>Purpose:</strong> Define a family of algorithms, encapsulate each one, and make them
                interchangeable.<br>
                <strong>Analogy:</strong> Like choosing different routes to reach the same destination (highway, scenic
                route, shortest path).<br>
                <strong>Use Case:</strong> When you have multiple ways to perform an operation and want to switch
                between them at runtime.
            </p>
            <pre><code class="language-java">// Strategy interface
public interface PaymentStrategy {
    void pay(int amount);
}

public class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card");
    }
}

public class PayPalPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}

// Context
public class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }
    
    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}</code></pre>

            <h3>3. Observer Pattern</h3>
            <p>
                <strong>Purpose:</strong> Define a one-to-many dependency so that when one object changes state, all
                dependents are notified.<br>
                <strong>Analogy:</strong> Like subscribing to a YouTube channelâ€”when a new video is uploaded, all
                subscribers get notified.<br>
                <strong>Use Case:</strong> Event handling systems, implementing distributed event handling.
            </p>
            <pre><code class="language-java">// Observer interface
public interface Observer {
    void update(String message);
}

// Subject
public class NewsAgency {
    private List<Observer> observers = new ArrayList<>();
    
    public void addObserver(Observer observer) {
        observers.add(observer);
    }
    
    public void notifyObservers(String news) {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// Concrete Observer
public class NewsChannel implements Observer {
    private String name;
    
    public void update(String news) {
        System.out.println(name + " received: " + news);
    }
}</code></pre>

            <h3>4. Builder Pattern</h3>
            <p>
                <strong>Purpose:</strong> Construct complex objects step by step.<br>
                <strong>Analogy:</strong> Like building a custom burgerâ€”choose bun, patty, toppings, sauce step by
                step.<br>
                <strong>Use Case:</strong> When an object has many optional parameters or complex construction logic.
            </p>
            <pre><code class="language-java">public class User {
    private String name;      // Required
    private String email;     // Required
    private int age;          // Optional
    private String phone;     // Optional
    
    private User(UserBuilder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
        this.phone = builder.phone;
    }
    
    public static class UserBuilder {
        private String name;
        private String email;
        private int age;
        private String phone;
        
        public UserBuilder(String name, String email) {
            this.name = name;
            this.email = email;
        }
        
        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }
        
        public UserBuilder phone(String phone) {
            this.phone = phone;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// Usage
User user = new User.UserBuilder("John", "john@email.com")
                    .age(30)
                    .phone("123-456-7890")
                    .build();</code></pre>

            <div class="callout note">
                <div class="callout-title">ğŸ“š NOTE</div>
                <p>These are just introductions. Each pattern deserves deep study. The Gang of Four (GoF) book
                    documents 23 design patterns in total!</p>
            </div>
        </div>

        <!-- Section 7: Layered Architecture -->
        <div class="content-section">
            <h2>ğŸ—ï¸ Layered Architecture</h2>

            <p>
                <strong>Baby:</strong> Like a sandwich with different layersâ€”bread, lettuce, cheese, meat. Each layer
                has its purpose!<br>
                <strong>Real-world:</strong> Like a building with floorsâ€”ground floor for shops, middle floors for
                offices, top floor for penthouse.<br>
                <strong>Technical:</strong> Organizing code into horizontal layers, each with a specific responsibility.
            </p>

            <h3>Three-Tier Architecture</h3>
            <pre
                style="background: var(--bg-hover); padding: var(--spacing-md); border-radius: var(--radius-sm); border-left: 4px solid var(--primary);">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation Layer (UI)           â”‚ â—„â”€â”€â”€ User Interface
â”‚   - Controllers                     â”‚      (Web pages, REST APIs)
â”‚   - Views/Templates                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Business Logic Layer (Service)    â”‚ â—„â”€â”€â”€ Business Rules
â”‚   - Services                        â”‚      (Validation, calculations)
â”‚   - Business Rules                  â”‚
â”‚   - Workflows                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Data Access Layer (Repository)    â”‚ â—„â”€â”€â”€ Database Operations
â”‚   - Repositories                    â”‚      (CRUD operations)
â”‚   - DAOs                            â”‚
â”‚   - Database Queries                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </pre>

            <h3>Layer Responsibilities</h3>

            <h4>1. Presentation Layer</h4>
            <ul>
                <li>Handles user interaction</li>
                <li>Displays data to users</li>
                <li>Captures user input</li>
                <li>Should NOT contain business logic</li>
            </ul>
            <pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    private UserService userService; // Delegates to business layer
    
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}</code></pre>

            <h4>2. Business Logic Layer</h4>
            <ul>
                <li>Contains business rules and logic</li>
                <li>Validates data</li>
                <li>Coordinates between presentation and data layers</li>
                <li>Independent of UI and database details</li>
            </ul>
            <pre><code class="language-java">@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; // Delegates to data layer
    
    public User findById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
    
    public void createUser(User user) {
        // Business validation
        if (user.getAge() < 18) {
            throw new InvalidAgeException("Must be 18+");
        }
        userRepository.save(user);
    }
}</code></pre>

            <h4>3. Data Access Layer</h4>
            <ul>
                <li>Handles database operations</li>
                <li>Abstracts data storage details</li>
                <li>Provides CRUD operations</li>
                <li>Can be swapped without affecting business logic</li>
            </ul>
            <pre><code class="language-java">@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByEmail(String email);
    List<User> findByAgeGreaterThan(int age);
}</code></pre>

            <h3>Benefits of Layered Architecture</h3>
            <ul>
                <li><strong>Separation of Concerns:</strong> Each layer has a clear responsibility</li>
                <li><strong>Maintainability:</strong> Changes in one layer don't affect others</li>
                <li><strong>Testability:</strong> Each layer can be tested independently</li>
                <li><strong>Reusability:</strong> Business logic can be reused across different UIs</li>
                <li><strong>Scalability:</strong> Layers can be scaled independently</li>
            </ul>

            <div class="callout warning">
                <div class="callout-title">âš ï¸ WARNING</div>
                <p>Don't skip layers! Presentation should never directly access the database. Always go through the
                    business layer.</p>
            </div>
        </div>

        <!-- Section 8: Best Practices -->
        <div class="content-section">
            <h2>âœ… Best Practices</h2>

            <h3>1. Write Clean and Readable Code</h3>
            <div class="callout tip">
                <div class="callout-title">ğŸ’¡ TIP</div>
                <ul>
                    <li>Use meaningful variable and method names</li>
                    <li>Keep methods short (ideally under 20 lines)</li>
                    <li>Use comments to explain "why," not "what"</li>
                    <li>Follow consistent naming conventions</li>
                    <li>Format code consistently (use IDE auto-formatting)</li>
                </ul>
            </div>

            <pre><code class="language-java">// BAD
public int calc(int a, int b) {
    return a * b * 365;
}

// GOOD
public int calculateAnnualSalary(int monthlySalary, int monthsWorked) {
    final int DAYS_IN_YEAR = 365;
    return monthlySalary * monthsWorked * DAYS_IN_YEAR;
}</code></pre>

            <h3>2. Design for Extensibility</h3>
            <p>
                Write code that can be easily extended without modification. Use interfaces, abstract classes, and
                design patterns.
            </p>
            <pre><code class="language-java">// Extensible design using Strategy pattern
public interface NotificationService {
    void send(String message);
}

// Easy to add new notification types
public class EmailNotification implements NotificationService {
    public void send(String message) { /* send email */ }
}

public class SMSNotification implements NotificationService {
    public void send(String message) { /* send SMS */ }
}

public class PushNotification implements NotificationService {
    public void send(String message) { /* send push */ }
}</code></pre>

            <h3>3. Use Interfaces Where Needed</h3>
            <p>
                Program to interfaces, not implementations. This makes your code flexible and testable.
            </p>
            <pre><code class="language-java">// GOOD - Depends on interface
public class OrderService {
    private PaymentProcessor paymentProcessor;
    
    public OrderService(PaymentProcessor processor) {
        this.paymentProcessor = processor;
    }
}

// Can easily swap implementations
PaymentProcessor processor = new StripePaymentProcessor();
// or
PaymentProcessor processor = new PayPalPaymentProcessor();</code></pre>

            <h3>4. Avoid Over-Engineering</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ WARNING</div>
                <p>Don't create elaborate architectures for simple problems. Start simple and refactor as needed.</p>
            </div>

            <pre><code class="language-java">// Over-engineered for a simple calculator
public interface CalculationStrategy { }
public class AdditionStrategy implements CalculationStrategy { }
public class CalculatorFactory { }
public class CalculatorContext { }

// Simple and sufficient
public class Calculator {
    public int add(int a, int b) { return a + b; }
    public int subtract(int a, int b) { return a - b; }
}</code></pre>

            <h3>5. Unit Testing Linkage</h3>
            <p>
                Good design principles make code testable. Following SOLID principles naturally leads to testable code.
            </p>
            <ul>
                <li><strong>SRP:</strong> Small, focused classes are easier to test</li>
                <li><strong>DIP:</strong> Dependency injection allows mocking dependencies</li>
                <li><strong>OCP:</strong> Extensible code can be tested without modification</li>
            </ul>

            <pre><code class="language-java">// Testable design with dependency injection
public class UserService {
    private UserRepository repository;
    private EmailService emailService;
    
    public UserService(UserRepository repo, EmailService email) {
        this.repository = repo;
        this.emailService = email;
    }
    
    public void registerUser(User user) {
        repository.save(user);
        emailService.sendWelcomeEmail(user);
    }
}

// Easy to test with mocks
@Test
public void testRegisterUser() {
    UserRepository mockRepo = mock(UserRepository.class);
    EmailService mockEmail = mock(EmailService.class);
    UserService service = new UserService(mockRepo, mockEmail);
    
    User user = new User("John");
    service.registerUser(user);
    
    verify(mockRepo).save(user);
    verify(mockEmail).sendWelcomeEmail(user);
}</code></pre>

            <h3>Additional Best Practices</h3>
            <ul>
                <li><strong>Fail Fast:</strong> Validate inputs early and throw exceptions for invalid data</li>
                <li><strong>Immutability:</strong> Prefer immutable objects when possible (use <code>final</code>)</li>
                <li><strong>Composition over Inheritance:</strong> Favor object composition over class inheritance</li>
                <li><strong>Code Reviews:</strong> Have peers review your code for quality and adherence to principles
                </li>
                <li><strong>Refactoring:</strong> Continuously improve code structure without changing behavior</li>
            </ul>
        </div>

        <!-- Section 9: Common Mistakes -->
        <div class="content-section">
            <h2>âŒ Common Mistakes</h2>

            <h3>1. Violation of Single Responsibility Principle</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <pre><code class="language-java">// BAD - God class doing everything
public class User {
    private String name;
    
    public void saveToDatabase() { }
    public void sendEmail() { }
    public void generateReport() { }
    public void calculateTax() { }
    public void processPayment() { }
}

// GOOD - Separate responsibilities
public class User {
    private String name;
}
public class UserRepository { void save(User u) { } }
public class EmailService { void send(User u) { } }
public class ReportGenerator { String generate(User u) { } }</code></pre>
            </div>

            <h3>2. Tight Coupling</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <pre><code class="language-java">// BAD - Tightly coupled
public class OrderService {
    private MySQLDatabase db = new MySQLDatabase(); // Hard-coded dependency
    
    public void saveOrder(Order order) {
        db.save(order); // Can't switch databases!
    }
}

// GOOD - Loose coupling via dependency injection
public class OrderService {
    private Database db;
    
    public OrderService(Database database) {
        this.db = database; // Flexible!
    }
}</code></pre>
            </div>

            <h3>3. Wrong Use of Singleton</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <p>Using Singleton for everything just to avoid passing parameters:</p>
                <pre><code class="language-java">// BAD - Singleton abuse
public class UserManager {
    private static UserManager instance;
    private User currentUser; // Shared state is dangerous!
    
    public static UserManager getInstance() { }
}

// GOOD - Pass user as parameter
public class UserService {
    public void processUser(User user) {
        // No global state!
    }
}</code></pre>
                <p><strong>Why it's bad:</strong> Global state makes testing difficult and can cause bugs in
                    multi-threaded environments.</p>
            </div>

            <h3>4. Overcomplicating Simple Logic</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <pre><code class="language-java">// BAD - Overcomplicated
public class AgeValidator {
    public boolean validate(int age) {
        if (age >= 18) {
            return true;
        } else {
            return false;
        }
    }
}

// GOOD - Simple and clear
public boolean isAdult(int age) {
    return age >= 18;
}</code></pre>
            </div>

            <h3>5. Not Following Naming Conventions</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <pre><code class="language-java">// BAD
public class usr {
    private String n;
    public void sv() { }
}

// GOOD
public class User {
    private String name;
    public void save() { }
}</code></pre>
            </div>

            <h3>6. Ignoring Exception Handling</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <pre><code class="language-java">// BAD - Swallowing exceptions
try {
    riskyOperation();
} catch (Exception e) {
    // Silent failure!
}

// GOOD - Proper handling
try {
    riskyOperation();
} catch (Exception e) {
    logger.error("Operation failed", e);
    throw new ServiceException("Failed to process", e);
}</code></pre>
            </div>

            <h3>7. Premature Optimization</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <p>"Premature optimization is the root of all evil" - Donald Knuth</p>
                <p>Don't optimize code before you have a performance problem. Write clean, readable code first, then
                    optimize if needed based on profiling.</p>
            </div>

            <h3>8. Not Writing Tests</h3>
            <div class="callout warning">
                <div class="callout-title">âš ï¸ MISTAKE</div>
                <p>Skipping unit tests to "save time" always backfires. Tests save time in the long run by catching
                    bugs early and enabling confident refactoring.</p>
            </div>
        </div>

        <!-- Next Topic -->
        <div class="next-topic">
            <p style="text-align: center; font-size: 1.2rem; margin-top: 2rem;">
                ğŸ‰ <strong>Congratulations!</strong> You've completed the Java Mastery Series!
            </p>
            <p style="text-align: center; color: var(--text-secondary);">
                You now have a solid foundation in Java programming principles and best practices.
            </p>
        </div>
    </div>

    <script src="../assets/js/mcq.js"></script>
</body>

</html>