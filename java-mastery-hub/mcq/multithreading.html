<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multithreading - Quiz - Java Mastery Hub</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <header>
        <div class="header-content">
            <div class="logo">
                <span class="logo-icon">‚òï</span>
                <span>Java Mastery Hub</span>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="content-header">
            <h1>Multithreading - Quiz</h1>
            <div class="breadcrumb">
                <a href="../index.html">Home</a>
                <span>/</span>
                <span>Quiz</span>
                <span>/</span>
                <span>Multithreading</span>
            </div>
        </div>

        <div class="content-section">
            <h2>Test Your Multithreading Knowledge</h2>
            <p>This quiz contains 30 questions covering all aspects of Java multithreading including thread creation,
                lifecycle, synchronization, executor framework, concurrency utilities, and best practices.</p>
            <div class="callout tip">
                <div class="callout-title">üí° TIP</div>
                <p>Take your time and read each question carefully. Pay special attention to code output questions and
                    synchronization scenarios. Aim for at least 80% to demonstrate mastery!</p>
            </div>
        </div>

        <div class="quiz-progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <div class="progress-text">
                <span id="currentQuestion">0</span> / <span id="totalQuestions">30</span> Questions
            </div>
        </div>

        <div id="quizContainer" class="content-section"></div>

        <div id="quizResults" class="content-section" style="display: none;">
            <h2>Quiz Complete! üéâ</h2>
            <div class="results-summary">
                <div class="score-display">
                    <div class="score-circle">
                        <span id="scorePercentage">0%</span>
                    </div>
                    <p class="score-text">Your Score: <span id="scoreText">0/30</span></p>
                </div>
                <div id="performanceMessage" class="performance-message"></div>
            </div>

            <div class="results-actions">
                <button onclick="quizManager.retakeQuiz()" class="btn btn-primary">üîÑ Retake Quiz</button>
                <a href="../theory/multithreading.html" class="btn btn-secondary">üìö Review Theory</a>
                <a href="../programs/multithreading.html" class="btn btn-secondary">üíª View Programs</a>
                <a href="../index.html" class="btn btn-success">üè† Back to Home</a>
            </div>
        </div>

        <div class="content-section text-center">
            <h3>Continue Your Learning Journey</h3>
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem;">
                <a href="../theory/multithreading.html" class="btn btn-primary">üìö Back to Theory</a>
                <a href="../programs/multithreading.html" class="btn btn-secondary">üíª View Programs</a>
                <a href="../index.html" class="btn btn-success">üè† Back to Home</a>
            </div>

            <div class="callout note" style="margin-top: 2rem;">
                <div class="callout-title">üöÄ Next Topic Coming Soon</div>
                <p><strong>Topic 14:</strong> Java 8+ Advanced Features & Enhancements</p>
            </div>
        </div>
    </div>

    <script src="../assets/js/mcq.js"></script>
    <script>
        const quizQuestions = [
            {
                id: 1,
                question: "What is a thread in Java?",
                options: ["A lightweight process", "A heavy process", "A class", "A package"],
                answerIndex: 0,
                explanation: "A thread is a lightweight subprocess, the smallest unit of processing. It's a separate path of execution within a program."
            },
            {
                id: 2,
                question: "Which package contains the Thread class?",
                options: ["java.util", "java.lang", "java.thread", "java.concurrent"],
                answerIndex: 1,
                explanation: "The Thread class is in the java.lang package, which is automatically imported in every Java program."
            },
            {
                id: 3,
                question: "What happens when you call run() directly instead of start()?",
                options: ["Creates a new thread", "Executes in the same thread (no new thread created)", "Throws an exception", "Does nothing"],
                answerIndex: 1,
                explanation: "Calling run() directly executes the method in the current thread like a normal method call. Only start() creates a new thread."
            },
            {
                id: 4,
                question: "Which method is used to create a new thread?",
                options: ["run()", "start()", "execute()", "begin()"],
                answerIndex: 1,
                explanation: "The start() method creates a new thread and calls the run() method internally. It can only be called once per thread object."
            },
            {
                id: 5,
                question: "How many ways can you create a thread in Java?",
                options: ["1", "2", "3", "4"],
                answerIndex: 1,
                explanation: "There are two main ways: 1) Extending the Thread class, 2) Implementing the Runnable interface. Implementing Runnable is preferred."
            },
            {
                id: 6,
                question: "What is the default priority of a thread?",
                options: ["1", "5", "10", "0"],
                answerIndex: 1,
                explanation: "The default thread priority is 5 (Thread.NORM_PRIORITY). Priorities range from 1 (MIN_PRIORITY) to 10 (MAX_PRIORITY)."
            },
            {
                id: 7,
                question: "Which of the following is NOT a valid thread state?",
                options: ["NEW", "RUNNABLE", "RUNNING", "SLEEPING"],
                answerIndex: 3,
                explanation: "SLEEPING is not a valid thread state. The valid states are: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, and TERMINATED."
            },
            {
                id: 8,
                question: "What does the sleep() method do?",
                options: ["Terminates the thread", "Pauses the thread for specified time", "Wakes up a waiting thread", "Creates a new thread"],
                answerIndex: 1,
                explanation: "Thread.sleep(milliseconds) pauses the current thread for the specified duration. It throws InterruptedException."
            },
            {
                id: 9,
                question: "What is the purpose of the join() method?",
                options: ["Combine two threads", "Wait for a thread to die", "Start a thread", "Pause a thread"],
                answerIndex: 1,
                explanation: "The join() method waits for a thread to complete its execution before the calling thread continues."
            },
            {
                id: 10,
                question: "What is a race condition?",
                options: ["When threads compete for CPU time", "When multiple threads access shared data concurrently causing inconsistent results", "When a thread runs very fast", "When threads are created in sequence"],
                answerIndex: 1,
                explanation: "A race condition occurs when two or more threads access shared data concurrently and try to change it, leading to unpredictable results."
            },
            {
                id: 11,
                question: "Which keyword is used to prevent race conditions?",
                options: ["volatile", "synchronized", "atomic", "locked"],
                answerIndex: 1,
                explanation: "The synchronized keyword ensures that only one thread can execute a block of code or method at a time, preventing race conditions."
            },
            {
                id: 12,
                question: "Can a synchronized method be called by multiple threads simultaneously?",
                options: ["Yes, always", "No, only one thread at a time", "Yes, if they have different priorities", "Depends on the JVM"],
                answerIndex: 1,
                explanation: "A synchronized method can only be executed by one thread at a time. Other threads must wait until the lock is released."
            },
            {
                id: 13,
                question: "What is a monitor lock in Java?",
                options: ["A hardware lock", "An intrinsic lock associated with every object", "A special thread", "A synchronization tool"],
                answerIndex: 1,
                explanation: "Every object in Java has an intrinsic lock (monitor lock). When a thread enters a synchronized method/block, it acquires this lock."
            },
            {
                id: 14,
                question: "Which methods are used for inter-thread communication?",
                options: ["sleep(), wake(), notify()", "wait(), notify(), notifyAll()", "pause(), resume(), stop()", "hold(), release(), signal()"],
                answerIndex: 1,
                explanation: "wait(), notify(), and notifyAll() are used for inter-thread communication. They must be called from within a synchronized context."
            },
            {
                id: 15,
                question: "Where must wait(), notify(), and notifyAll() be called?",
                options: ["Anywhere in the code", "Only in the main method", "Within a synchronized context", "Only in Thread class"],
                answerIndex: 2,
                explanation: "These methods must be called from within a synchronized method or block. Otherwise, they throw IllegalMonitorStateException."
            },
            {
                id: 16,
                question: "What is a daemon thread?",
                options: ["A high-priority thread", "A low-priority background thread", "A thread that never terminates", "A thread that runs on a separate JVM"],
                answerIndex: 1,
                explanation: "Daemon threads are low-priority threads that run in the background (e.g., garbage collection). JVM exits when only daemon threads remain."
            },
            {
                id: 17,
                question: "When should you call setDaemon(true)?",
                options: ["After calling start()", "Before calling start()", "Anytime", "Never"],
                answerIndex: 1,
                explanation: "setDaemon(true) must be called BEFORE calling start(). Calling it after start() throws IllegalThreadStateException."
            },
            {
                id: 18,
                question: "What is deadlock?",
                options: ["When a thread dies", "When two or more threads are blocked forever, waiting for each other", "When a thread runs too slowly", "When a thread has low priority"],
                answerIndex: 1,
                explanation: "Deadlock occurs when two or more threads are blocked forever, each waiting for the other to release a lock."
            },
            {
                id: 19,
                question: "How can you prevent deadlock?",
                options: ["Use higher thread priorities", "Always acquire locks in the same order", "Use more threads", "Avoid using threads"],
                answerIndex: 1,
                explanation: "One way to prevent deadlock is to always acquire locks in the same order across all threads. This prevents circular wait conditions."
            },
            {
                id: 20,
                question: "What is the Executor framework?",
                options: ["A class for executing code", "A higher-level replacement for working with threads directly", "A debugging tool", "A thread priority manager"],
                answerIndex: 1,
                explanation: "The Executor framework provides a higher-level API for thread management, including thread pools, task scheduling, and lifecycle management."
            },
            {
                id: 21,
                question: "Which method creates a fixed-size thread pool?",
                options: ["Executors.newThreadPool()", "Executors.newFixedThreadPool(n)", "Executors.createPool(n)", "new ThreadPool(n)"],
                answerIndex: 1,
                explanation: "Executors.newFixedThreadPool(n) creates a thread pool with a fixed number of threads that are reused for executing tasks."
            },
            {
                id: 22,
                question: "What is the difference between Runnable and Callable?",
                options: ["No difference", "Callable can return a value and throw checked exceptions", "Runnable is faster", "Callable doesn't need a thread"],
                answerIndex: 1,
                explanation: "Callable can return a value and throw checked exceptions, while Runnable cannot return a value and can only throw unchecked exceptions."
            },
            {
                id: 23,
                question: "What does Future represent?",
                options: ["A future thread", "The result of an asynchronous computation", "A scheduled task", "A thread pool"],
                answerIndex: 1,
                explanation: "Future represents the result of an asynchronous computation. You can use get() to retrieve the result, which blocks until available."
            },
            {
                id: 24,
                question: "What is the purpose of volatile keyword?",
                options: ["Make variables constant", "Ensure visibility of changes across threads", "Increase performance", "Prevent exceptions"],
                answerIndex: 1,
                explanation: "The volatile keyword ensures that changes to a variable are immediately visible to all threads. It prevents thread caching of the variable."
            },
            {
                id: 25,
                question: "What is CountDownLatch used for?",
                options: ["Counting threads", "Allowing threads to wait until a set of operations completes", "Creating threads", "Destroying threads"],
                answerIndex: 1,
                explanation: "CountDownLatch allows one or more threads to wait until a set of operations being performed in other threads completes."
            },
            {
                id: 26,
                question: "What is the difference between synchronized and Lock?",
                options: ["No difference", "Lock provides more flexibility and features", "synchronized is faster", "Lock is deprecated"],
                answerIndex: 1,
                explanation: "Lock interface provides more flexibility than synchronized, including try-lock, timed lock, interruptible lock, and multiple condition variables."
            },
            {
                id: 27,
                question: "What is ConcurrentHashMap?",
                options: ["A synchronized HashMap", "A thread-safe map with better concurrency than Hashtable", "A map that runs in multiple threads", "A faster HashMap"],
                answerIndex: 1,
                explanation: "ConcurrentHashMap is a thread-safe map that allows concurrent reads and writes without locking the entire map, providing better performance than Hashtable."
            },
            {
                id: 28,
                question: "What happens if you don't call shutdown() on an ExecutorService?",
                options: ["Nothing", "The program may not terminate", "Throws an exception", "Threads are automatically stopped"],
                answerIndex: 1,
                explanation: "If you don't call shutdown(), the ExecutorService keeps running and the program may not terminate because the threads are still alive."
            },
            {
                id: 29,
                question: "What is thread starvation?",
                options: ["When a thread dies", "When a thread is unable to gain regular access to shared resources", "When a thread runs too fast", "When a thread has no work"],
                answerIndex: 1,
                explanation: "Thread starvation occurs when a thread is unable to gain regular access to shared resources and is unable to make progress."
            },
            {
                id: 30,
                question: "What is the output of this code?\n\nThread t = new Thread(() -> System.out.println(\"Hello\"));\nt.run();\nt.run();",
                options: ["Hello (printed once)", "Hello (printed twice)", "Exception thrown", "Nothing printed"],
                answerIndex: 1,
                explanation: "Calling run() directly executes it like a normal method in the same thread. It can be called multiple times, so 'Hello' is printed twice. No new thread is created."
            },
            {
                id: 31,
                question: "Which is the correct way to stop a thread?",
                options: ["thread.stop()", "Use a volatile boolean flag", "thread.destroy()", "thread.kill()"],
                answerIndex: 1,
                explanation: "The correct way is to use a volatile boolean flag that the thread checks periodically. The stop() method is deprecated and unsafe."
            },
            {
                id: 32,
                question: "What is the purpose of yield() method?",
                options: ["Stop the thread", "Hint to scheduler that current thread is willing to yield CPU", "Wait for another thread", "Create a new thread"],
                answerIndex: 1,
                explanation: "yield() is a hint to the thread scheduler that the current thread is willing to yield its current use of CPU. The scheduler may ignore this hint."
            },
            {
                id: 33,
                question: "What is a Semaphore?",
                options: ["A type of thread", "A synchronization aid that controls access to shared resources through permits", "A thread pool", "A lock mechanism"],
                answerIndex: 1,
                explanation: "Semaphore controls access to a shared resource through the use of permits. Threads acquire permits before accessing and release them after."
            },
            {
                id: 34,
                question: "What is CyclicBarrier used for?",
                options: ["Creating barriers in code", "Allowing threads to wait for each other at a common barrier point", "Preventing thread creation", "Stopping threads"],
                answerIndex: 1,
                explanation: "CyclicBarrier allows a set of threads to wait for each other to reach a common barrier point before continuing execution."
            },
            {
                id: 35,
                question: "Which is better for a simple counter: synchronized or AtomicInteger?",
                options: ["synchronized", "AtomicInteger", "Both are equal", "Neither"],
                answerIndex: 1,
                explanation: "AtomicInteger is better for simple counters as it provides lock-free thread-safe operations with better performance than synchronized."
            }
        ];

        document.addEventListener('DOMContentLoaded', function () {
            const quizManager = new QuizManager('quizContainer', 'quizResults', quizQuestions);
            quizManager.startQuiz();
            window.quizManager = quizManager;
        });
    </script>
</body>

</html>